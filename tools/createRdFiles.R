library(PythonEmbedInR)
library(rjson)

# create the autogenerated files
# srcRootDir is the root directory for the code base (i.e., prior to installation)
# the target dir is <srcRootDir>/man
autoGenerateRdFiles<-function(srcRootDir) {
	if (!file.exists(srcRootDir)) {
		stop(sprintf("%s does not exist.", srcRootDir))
	}

	functionInfo<-.getSynapseFunctionInfo(file.path(srcRootDir, "inst"))
	classInfo<-.getSynapseClassInfo(file.path(srcRootDir, "inst"))
	constructorInfo<-lapply(X=classInfo, function(x){
				list(synName=x$name, args=x$constructorArgs, doc=x$doc, desc=sprintf("Constructor for objects of type %s", x$name))
			})
	for (f in c(functionInfo,constructorInfo)) { 
		name<-f$synName
		args<-f$args
		doc<-f$doc
		tryCatch({
				content<-createFunctionRdContent(srcRootDir=srcRootDir,
						alias=name,
						title=name,
						description=f$desc,
						usage=usage(name, args),
						argument = formatArgsForArgumentSection(args, doc),
						details=doc
				)
				writeContent(content, name, srcRootDir)
			}, 
			error=function(e){
				stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
			}
		)
	}

	for (c in classInfo) { 
		tryCatch({
					name<-paste0(c$name, "-class")
					content<-createClassRdContent(srcRootDir=srcRootDir,
							alias=name,
							title=name,
							description=c$doc,
							methods=lapply(X=c$methods, function(x){list(name=x$name,description=x$doc,args=x$args)})
					)
					writeContent(content, name, srcRootDir)
				}, 
				error=function(e){
					stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
				}
		)
	}
}

usage<-function(name, args) {
	result<-NULL
	argNames<-args$args
	keywords<-args$keywords
	varargs<-args$varargs
	defaults<-args$defaults
	result<-NULL
	if (length(argNames)>0) {
		# self can be the first arg of a method or function, typ can be the first arg of a constructor
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[i]
				defaultIndex<- i+length(defaults)-length(argNames)
				if (defaultIndex>0) {
					result<-append(result, sprintf("%s=%s", argName, defaults[defaultIndex]))
				} else {
					result<-append(result, argName)
				}
			}
		}
	}
	if (!is.null(keywords) || !is.null(varargs)) result<-append(result, "...")
	sprintf("%s(%s)", name, paste(result, collapse=", "))
}

formatArgsForArgumentSection<-function(args, details) {
	argNames<-args$args
	result<-NULL
	argDescriptions<-parseArgDescriptionsFromDetails(details)
	if (length(argNames)>0) {
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[[i]]
				argDescription<-argDescriptions[[argName]]
				if (is.null(argDescription)) argDescription<-""
				result<-append(result, sprintf("\\item{%s}{%s}", argName, argDescription))
			}
		}
	}
	paste(result, collapse="\n")
}

formatArgsForArgList<-function(args) {
	argNames<-args$args
	defaults<-args$defaults
	result<-NULL
	if (length(argNames)>0) {
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[[i]]
				defaultIndex<- i+length(defaults)-length(argNames)
				if (defaultIndex>0) {
					result<-append(result, sprintf("%s=%s", argName, defaults[defaultIndex]))
				} else {
					result<-append(result, argName)
				}
			}
		}
	}
	paste(result, collapse=", ")
}

getDictDocString<-function(srcRootDir) {
	file<-sprintf("%s/tools/dictDocString.txt", srcRootDir)
	connection<-file(file, open="r")
	result<-paste(readLines(connection), collapse="\n")
	close(connection)
	result
}

parseArgDescriptionsFromDetails<-function(raw) {
	# escape any escaped-escapes
	preprocessed<-gsub("\\\\", "\\\\\\\\", raw)
	# change all quotes to escaped quotes
	preprocessed<-gsub("\"", "\\\\\"", preprocessed)
	# change \r\n to \n
	preprocessed<-gsub("\r\n", "\n", preprocessed)

	# find parameters and convert them, along with their def'ns, to json
	# reminder: \w in a regexp means "word character", [A-Za-z0-9_]
	json<-gsub(":(parameter|param|type|var) (\\w+):", "\",\"\\2\":\"", preprocessed)
	# prepend "{\"unusedPrefix\":\""
	# add "\"}" to the end
	json<-paste0("{\"unusedPrefix\":\"", json, "\"}")
	# parse JSON into named list
	paramsList<-fromJSON(json)
	# truncate each entry at double-new-line
	result<-lapply(paramsList, 
		function(x) {
			p<-regexpr("\n\n", x)
			if(p<0)return(x)
			substr(x,1,p-1)
		}
	)
	result$unusedPrefix<-NULL
	result
}

processDetails<-function(raw, dictDocString=NULL) {
	# TODO there might be convertable content AFTER the double colon.  One case is 
	# that in which the :returns: field comes after the example.
	result<-gsub("Example::.*$", "", raw) # remove 'Example::' and everything following
	result<-gsub("::.*$", "", result) # remove '::' and everything following
	# this replaces ':param <param name>:' with '\nparam name:'
	# same for parameter, type, var
	result<-gsub(":(parameter|param|type|var) (\\w+):", "\n\\2:", result)
	result<-gsub(":returns:", "returns:", result)
	result<-gsub(":py:class:`(\\S+\\.)*(\\S+)`", "\\2", result)
	
	convertToUpper<-"##convertToUpper##" # marks character to convert
	result<-gsub(":py:mod:`(\\S+\\.)*(\\S+)`", paste0(convertToUpper,"\\2"), result)
	result<-gsub(":py:func:`Synapse.(\\w+)`", paste0("syn", convertToUpper,"\\1"), result)
	result<-gsub(":py:func:`synapseclient.Synapse.(\\w+)`", paste0("syn",convertToUpper,"\\1"), result)
	result<-gsub(":py:meth:`synapseclient.Synapse.(\\w+)`", paste0("syn",convertToUpper,"\\1"), result)
	while (TRUE) {
		ctuIndex<-regexpr(convertToUpper, result)[[1]]
		if (ctuIndex<0) break
		lcChar<-nchar(convertToUpper)+ctuIndex
		result<-paste0(substring(result,1,ctuIndex-1), 
				toupper(substring(result,lcChar,lcChar)), 
				substring(result, lcChar+1))
	}
	if (!is.null(dictDocString)) {
		result<-gsub(dictDocString, "\nConstructor accepts arbitrary named arguments.\n", result, fixed=TRUE)
	}
	result	
}

getReturned<-function(raw) {
	NULL
}

createFunctionRdContent<-function(srcRootDir, alias, title, description, usage, argument, details) {
	templateFile<-sprintf("%s/tools/rdFunctionTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	if (!missing(description) && !is.null(description)) content<-gsub("##description##", description, content, fixed=TRUE)
	if (!missing(usage) && !is.null(usage)) content<-gsub("##usage##", usage, content, fixed=TRUE)
	if (!missing(argument) && !is.null(argument)) content<-gsub("##arguments##", argument, content, fixed=TRUE)
	returned<-NULL
	if (!missing(details) && !is.null(details)) {
		processedDetails<-processDetails(details)
		content<-gsub("##details##", processedDetails, content, fixed=TRUE)
		returned<-getReturned(details)
	}
	if (is.null(returned)) {
		content<-gsub("##value##", "", content, fixed=TRUE)
	} else {
		content<-gsub("##value##", "\value{\n"+returned+"\n}\n", content, fixed=TRUE)
	}
	content
}

createMethodContent<-function(f) {
	paste0("\\item \\code{", f$name, "(", formatArgsForArgList(f$args), ")", "}: ", f$description)
}

createClassRdContent<-function(srcRootDir, alias, title, description, methods) {
	templateFile<-sprintf("%s/tools/rdClassTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	if (!missing(description) && !is.null(description)) {
		dictDocString<-getDictDocString(srcRootDir)		
		processedDetails<-processDetails(description, dictDocString)
		content<-gsub("##description##", processedDetails, content, fixed=TRUE)
	}
	methodContent<-NULL
	for (method in methods) {

		methodContent<-c(methodContent, createMethodContent(method))
	}
	content<-gsub("##methods##", paste(methodContent, collapse="\n"), content, fixed=TRUE)
	content
}


writeContent<-function(content, className, srcRootDir) {
	fileName<-sprintf("%s/man/%s.Rd", srcRootDir, className)
	connection<-file(fileName, open="w")
	writeChar(content, connection, eos=NULL)
	writeChar("\n", connection, eos=NULL)
	close(connection)
}
